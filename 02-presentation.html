<section id="presentation">

    <section>
        <h2>Présentation</h2>
    </section>

    <section>
        <h3>Qu'est-ce que les design patterns</h3>
        <p>
            Les design patterns (ou patrons de conception en français) sont des manières d'<strong>organiser son code
            source</strong> pour répondre à des <strong>problématiques récurrentes</strong> en programmation.
        </p>
        <p>
            La majorité des design patterns sont basés sur la <strong>programmation orientée objet</strong> et décrivent
            l'organisation et les interactions entre des classes et des interfaces. Ils sont souvent représentés à
            l'aide d'un <strong>diagramme UML de classe</strong>.
        </p>
        <p>
            Ce sont des <strong>méthodes éprouvées</strong> qui sont utilisées depuis les années 90.
        </p>
    </section>

    <section>
        <h3>Analogie avec les nœuds marins</h3>
        <p>
            On peut comparer les design patterns aux nœuds marins, car les nœuds marins permettent de <strong>répondre
            à des problématiques</strong> (lier deux cordes, s'amarrer, terminer un cordage...) en proposant plusieurs
            techniques adaptées à chaque situation.
        </p>
        <p>
            Il existe tout un <strong>catalogue</strong> de nœuds marins que l'on pourrait catégoriser par type
            d'utilisation.
        </p>
        <p>
            De plus, les nœuds marins pourront être réalisés <strong>quel que soit le type de cordage</strong> utilisé.
        </p>
    </section>

    <section>
        <h3>Analogie avec les nœuds marins</h3>
        <table>
            <tr>
                <td><img src="/assets/images/knot-clove-hitch.jpg" alt="Nœud de cabestan"></td>
                <td>Nœud de cabestan</td>
                <td>Pour s'amarrer</td>
            </tr>
            <tr>
                <td><img src="/assets/images/knot-stopper.jpg" alt="Nœud de huit double"></td>
                <td>Nœud de huit double</td>
                <td>Pour terminer un cordage</td>
            </tr>
            <tr>
                <td><img src="/assets/images/knot-bowline.jpg" alt="Nœud de chaise"></td>
                <td>Nœud de chaise</td>
                <td>Pour réaliser une boucle</td>
            </tr>
        </table>
    </section>

    <section>
        <h3>Analogie avec les nœuds marins</h3>
        <p>
            On peut très bien ne pas connaître les nœuds marins et naviguer sur un bateau à voile en <strong>inventant
            ses propres nœuds</strong>, mais cela risque d'être relativement <strong>compliqué et incertain</strong>.
        </p>
        <p>
            On pourrait par exemple se rendre compte que l'un des nœuds que l'on a utilisé sur 15 cordes sur le bateau
            ne tient pas et qu'il faudrait finalement le <strong>remplacer par un nœud de chaise</strong>.
        </p>
        <p>
            De plus, si l'on invite un ami pour naviguer sur notre bateau, il faudra lui <strong>apprendre les
            nœuds</strong> que nous avons inventés pour qu'il puisse les reproduire alors qu'il connait peut-être déjà
            les nœuds marins classiques.
        </p>
        <p>
            Enfin, les nœuds marins existent depuis maintenant des centaines d'années, on peut donc penser que leur
            <strong>fiabilité est éprouvée</strong> et que l'on peut les utiliser sans risque.
        </p>
        <p>
            Attention cependant à <strong>ne pas abuser</strong> des nœuds marins... On ne va peut-être pas les
            utiliser pour lacer ses chaussures !
        </p>
    </section>

    <section>
        <h3>Autres analogies</h3>
        <p>Pouvez-vous trouver d'autres analogies de la vie quotidienne ?</p>
    </section>

    <section>
        <h3>Historique</h3>
        <div class="container">
            <div class="col">
                <p>
                    Le concept de pattern à été introduit en 1977 par Christopher Alexander dans le domaine de l'architecture
                    urbaine via la rédaction du livre "A Pattern Language: Towns, Buildings, Construction".
                </p>
                <p>
                    Ce livre propose 250 patterns sur la meilleure <strong>manière d'organiser une architecture urbaine</strong>
                    (hauteur des murs, espaces verts, balcons des maisons...).
                </p>
            </div>
            <div class="col">
                <img src="/assets/images/christopher-alexander-book.jpg" alt="A Pattern Language: Towns, Buildings, Construction">
            </div>
        </div>
    </section>

    <section>
        <h3>Historique</h3>
        <div class="slide-container">
            <img src="/assets/images/christopher-alexander-example.png" alt="Exemple Christopher Alexander">
        </div>
    </section>

    <section>
        <h3>Historique</h3>
        <div class="container">
            <div class="col">
                <p>
                    Le concept de pattern a ensuite été repris en programmation informatique et popularisé en 1994 avec la
                    parution du livre "Design Patterns: Elements of Reusable Object-Oriented Software".
                </p>
                <p>
                    Ce livre présente 23 patterns qui sont <strong>aujourd'hui toujours très utilisés</strong> par les
                    développeurs.
                </p>
                <p>
                    Il a été rédigé par 4 auteurs surnomés le "Gang of Four" (ou GoF).
                </p>
            </div>
            <div class="col">
                <img src="/assets/images/book-gof.jpg" alt="Design Patterns: Elements of Reusable Object-Oriented Software">
            </div>
        </div>
    </section>

    <section>
        <h3>Organisation des design patterns</h3>
        <div class="container" style="align-items: center;">
            <div class="col">
                <img src="/assets/images/gof-design-patterns.jpg" alt="Organisation design patterns">
            </div>
            <div class="col" style="flex: 0;">
                <ul class="design-pattern-category-list">
                    <li>
                        <div class="design-pattern-category background-creational">C</div>
                        <div>Creational</div>
                    </li>
                    <li>
                        <div class="design-pattern-category background-structural">S</div>
                        <div>Structural</div>
                    </li>
                    <li>
                        <div class="design-pattern-category background-behavioral">B</div>
                        <div>Behavioral</div>
                    </li>
                </ul>
            </div>
        </div>
    </section>

    <section>
        <h3>Organisation des design patterns</h3>
        <ul class="design-pattern-category-list">
            <li>
                <div class="design-pattern-category background-creational">C</div>
                <div>Creational</div>
            </li>
            <li>
                <p>
                    Ces patterns sont utilisés pour l'instantiation des classes.
                    Ils peuvent aider à la construction de classes ou d'objets.
                </p>
            </li>
            <li>
                <div class="design-pattern-category background-structural">S</div>
                <div>Structural</div>
            </li>
            <li>
                <p>
                    Ces patterns traitent de la structure et de la composition des classes.
                    L'objectif principal est de pouvoir ajouter des fonctionnalités sur une classe sans en changer sa
                    composition.
                </p>
            </li>
            <li>
                <div class="design-pattern-category background-behavioral">B</div>
                <div>Behavioral</div>
            </li>
            <li>
                <p>Ces patterns permettent d'aider à structurer la communication entre plusieurs classes.</p>
            </li>
        </ul>
    </section>

    <section>
        <h3>Relations entre les design patterns</h3>
        <div class="slide-container">
            <img src="/assets/images/relationships.png" alt="Relations">
        </div>
    </section>

    <section>
        <h3>Principes de la POO</h3>
        <p>
            <strong>Composition over inheritance</strong> :
            Préférer utiliser le principe de composition plutôt que l'héritage
        </p>
        <p>
            <strong>Program to an 'interface', not an 'implementation'</strong> :
            Favoriser l'utilisation d'interfaces plutôt que des classes concrètes.
        </p>
    </section>

    <section>
        <h3>SOLID</h3>
        <p>
            <strong>Single-responsibility principle</strong> :
            Chaque classe ne doit avoir qu'une seule responsabilité.
        </p>
        <p>
            <strong>Open–closed principle</strong> :
            Le code doit être ouvert à l'extension mais fermé à la modification.
        </p>
        <p>
            <strong>Liskov substitution principle</strong> :
            Une fonction utilisant la référence d'un type doit pouvoir utiliser les références de ses
            sous-types sans les connaître (polymorphisme).
        </p>
        <p>
            <strong>Interface segregation principle</strong> :
            Plusieurs interfaces spécifiques sont meilleures qu'une seule interface générique.
        </p>
        <p>
            <strong>Dependency inversion principle</strong> :
            Dépendre des abstractions et non des implémentations.
        </p>
    </section>

    <section>
        <h3>Dependency Injection (DI)</h3>
        <p>
            L'injection de dépendance est une technique en programmation orientée objet qui permet de
            <strong>favoriser la composition</strong> et d'éviter l'utilisation de l'héritage (composition over
            inheritance).
        </p>
        <p>
            Elle consiste à passer une dépendance à une classe via son <strong>constructeur</strong>, une
            <strong>méthode</strong> ou bien directement via une <strong>propriété</strong>.
        </p>
    </section>

    <section>
        <h3>Dependency Injection (DI)</h3>
        <img src="/assets/images/puzzle.webp" alt="Puzzle">
        <p>
            Dans le puzzle ci-dessus, une pièce est manquante.
            Je pourrais choisir d'y insérer une pièce de puzzle <strong>rouge, verte, bleue</strong>...
        </p>
        <p>
            Cependant, je serais obligé de <strong>respecter la forme</strong> de la pièce.
        </p>
    </section>

    <section>
        <h3>Dependency Injection (DI)</h3>
        <p>
            On pourrait représenter l'exemple précédent avec un code source de ce type :
        </p>
<pre><code class="language-php">class Puzzle {
    private Piece $missingPiece;

    public function __construct(Piece $piece) // L'injection ce fait via le constructeur
    {
        $this->missingPiece = $piece;
    }
}</code></pre>
        <p>
            <code class="language-php">Piece</code> pourrait être une classe ou bien une interface.
            Elle obligera les développeurs à passer en paramètre du constructeur un objet qui respectera une
            <strong>forme</strong> bien précise (avec des méthodes, des attributs...).
        </p>
    </section>

    <section>
        <h3>Dependency Injection Container (DIC)</h3>
        <p>
            Les frameworks modernes utilisent des conteneurs de dépendances qui permettent de faciliter la
            construction d'objets et qui peuvent être utilisés comme des <strong>services</strong>.
        </p>
        <p>
            Il sera ensuite possible via un système <strong>d'auto-wiring</strong> basé sur la <strong>reflection</strong>
            d'injecter dynamiquement des services dans des classes.
        </p>
        <p>
            Cela permet de mettre en place le principe d'<strong>Inversion of Control</strong> (IoC).
            Ce dernier permet à un framework de contrôler l'exécution d'un programme, le développeur ne faisant
            qu'injecter des comportements à certains moments de l'exécution du programme.
        </p>
        <blockquote>
            <p>Don't call us, we'll call you</p>
            <cite>Hollywood Principle</cite>
        </blockquote>
    </section>

    <section>
        <h3>Dependency Injection Container (DIC)</h3>
        <p>
            Par exemple, dans le framework Symfony, le code suivant permet de récupérer le repository des produits
            dans une méthode d'un controller :
        </p>
        <pre><code class="language-php">namespace App\Controller;

use App\Repository\ProductRepository;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;

class ProductController extends AbstractController
{
    // L'auto-wiring permettra d'injecter automatiquement le service ProductRepository
    public function show(ProductRepository $productRepository)
    {
        $products = $productRepository->findAll();
    }
}</code></pre>
    </section>

</section>
