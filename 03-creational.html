<section id="creational" data-background="#9ec9eb">

  <section>
    <h2>Creational</h2>
  </section>

  <section>
    <h3>Présentation</h3>
    <p>
      Les design patterns de création permettent d'aider à la <strong>construction d'objets</strong>.
    </p>
  </section>

  <section>
    <h3>Builder</h3>
    <p>
      Le pattern <strong>Builder</strong> vous permet de construire des objets complexes étape par étape.
    </p>
    <img src="/assets/images/builder.png" alt="Builder">
    <footer>
      <a href="https://refactoring.guru/design-patterns/builder" target="_blank" class="info">refactoring.guru</a>
    </footer>
  </section>

    <section>
        <h3>Builder</h3>
        <p>
            Dans cet exemple, nous allons utiliser le design pattern Builder pour permettre de générer des Smiley en
            ASCII. Nous souhaitons pouvoir créer plusieurs type de Smiley (content, triste...) et que les Smiley
            puisse être plus ou moins complet (avec ou sans nez).
        </p>
        <img src="/assets/images/builder-smiley.png" alt="Builder Pattern">
        <footer>
            <a href="/assets/files/code_examples.zip" class="info">Télécharger le code source des exemples</a>
        </footer>
    </section>

    <section>
        <h3>Builder</h3>
        <p>
            Dans cet exemple, il était également possible d'utiliser une classe abstraite plutôt qu'une interface pour
            éviter de répéter les méthodes <code class="language-php">addToFace()</code>,
            <code class="language-php">reset()</code> et <code class="language-php">getResult()</code>.
        </p>
        <img src="/assets/images/builder-smiley-with-abstract-class.png" alt="Builder Pattern avec classe abstraite">
    </section>

  <section>
    <h3>Builder</h3>
    <p>
      L'ORM Doctrine utilise le design pattern Builder pour la construction de requêtes via la classe
      <code class="language-php">QueryBuilder</code> :
    </p>
<pre><code class="language-php">$qb = $em->createQueryBuilder(); // $em instanceof EntityManager

$qb->select('u')
    ->from('User', 'u')
    ->where('u.id = :identifier')
    ->orderBy('u.name', 'ASC')
    ->setParameter('identifier', 100);

$query = $qb->getQuery();</code></pre>
  </section>

  <section>
    <h3>Builder</h3>
    <p>
      Le framework Symfony et son composant Form utilisent le design pattern Builder pour la construction de
      formulaires via la classe <code class="language-php">FormBuilder</code> :
<pre><code class="language-php">public function buildForm(FormBuilderInterface $builder, array $options): void
{
    $builder
        ->add('task', TextType::class)
        ->add('dueDate', DateType::class)
        ->add('save', SubmitType::class)
    ;
}
</code></pre>
    </p>
  </section>

  <section>
    <h3>Builder</h3>
    <figure>
      <img src="/assets/images/symfony-form-builder.png" alt="Symfony FormBuilder UML">
      <figcaption>Diagramme de classe UML du FormBuilder de Symfony</figcaption>
    </figure>
  </section>

  <section>
    <h3>Builder</h3>
    <p>
      Écrire le code source d'une librairie permettant de
    </p>
    <div class="instructions">
      <ol>
        <li></li>
      </ol>
    </div>
  </section>

  <section>
    <h3>Factory</h3>
    <p>
      La classe <code class="language-php">EntityManager</code> de Doctrine utilise le design pattern factory :
    </p>
<pre><code class="language-php">public static function create($connection, Configuration $config, ?EventManager $eventManager = null)
{
    if (! $config->getMetadataDriverImpl()) {
        throw ORMException::missingMappingDriverImpl();
    }

    $connection = static::createConnection($connection, $config, $eventManager);

    return new EntityManager($connection, $config, $connection->getEventManager());
}</code></pre>
  </section>

</section>
